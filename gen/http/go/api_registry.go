/*
Swagger for Not Platform

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package not-games-sdk-public

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RegistryAPIService RegistryAPI service
type RegistryAPIService service

type ApiRegistryAchievementsAchievementDefIdDeleteRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	achievementDefId string
}

func (r ApiRegistryAchievementsAchievementDefIdDeleteRequest) Execute() (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	return r.ApiService.RegistryAchievementsAchievementDefIdDeleteExecute(r)
}

/*
RegistryAchievementsAchievementDefIdDelete Delete achievement-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param achievementDefId achievement_def_id
 @return ApiRegistryAchievementsAchievementDefIdDeleteRequest
*/
func (a *RegistryAPIService) RegistryAchievementsAchievementDefIdDelete(ctx context.Context, achievementDefId string) ApiRegistryAchievementsAchievementDefIdDeleteRequest {
	return ApiRegistryAchievementsAchievementDefIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		achievementDefId: achievementDefId,
	}
}

// Execute executes the request
//  @return GithubComNotPlatformInternalServerTemplatesResponseTemplate
func (a *RegistryAPIService) RegistryAchievementsAchievementDefIdDeleteExecute(r ApiRegistryAchievementsAchievementDefIdDeleteRequest) (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GithubComNotPlatformInternalServerTemplatesResponseTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryAchievementsAchievementDefIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/achievements/{achievement_def_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"achievement_def_id"+"}", url.PathEscape(parameterValueToString(r.achievementDefId, "achievementDefId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryAchievementsAchievementDefIdGetRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	achievementDefId string
}

func (r ApiRegistryAchievementsAchievementDefIdGetRequest) Execute() (*RegistryAchievementsAchievementDefIdGet200Response, *http.Response, error) {
	return r.ApiService.RegistryAchievementsAchievementDefIdGetExecute(r)
}

/*
RegistryAchievementsAchievementDefIdGet Get achievement-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param achievementDefId achievement_def_id
 @return ApiRegistryAchievementsAchievementDefIdGetRequest
*/
func (a *RegistryAPIService) RegistryAchievementsAchievementDefIdGet(ctx context.Context, achievementDefId string) ApiRegistryAchievementsAchievementDefIdGetRequest {
	return ApiRegistryAchievementsAchievementDefIdGetRequest{
		ApiService: a,
		ctx: ctx,
		achievementDefId: achievementDefId,
	}
}

// Execute executes the request
//  @return RegistryAchievementsAchievementDefIdGet200Response
func (a *RegistryAPIService) RegistryAchievementsAchievementDefIdGetExecute(r ApiRegistryAchievementsAchievementDefIdGetRequest) (*RegistryAchievementsAchievementDefIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegistryAchievementsAchievementDefIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryAchievementsAchievementDefIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/achievements/{achievement_def_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"achievement_def_id"+"}", url.PathEscape(parameterValueToString(r.achievementDefId, "achievementDefId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryAchievementsAchievementDefIdPutRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	achievementDefId string
	request *InternalModuleRegistryPresentationAchievementHttpUpdateRequest
}

// request body
func (r ApiRegistryAchievementsAchievementDefIdPutRequest) Request(request InternalModuleRegistryPresentationAchievementHttpUpdateRequest) ApiRegistryAchievementsAchievementDefIdPutRequest {
	r.request = &request
	return r
}

func (r ApiRegistryAchievementsAchievementDefIdPutRequest) Execute() (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	return r.ApiService.RegistryAchievementsAchievementDefIdPutExecute(r)
}

/*
RegistryAchievementsAchievementDefIdPut Update achievement-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param achievementDefId achievement_def_id
 @return ApiRegistryAchievementsAchievementDefIdPutRequest
*/
func (a *RegistryAPIService) RegistryAchievementsAchievementDefIdPut(ctx context.Context, achievementDefId string) ApiRegistryAchievementsAchievementDefIdPutRequest {
	return ApiRegistryAchievementsAchievementDefIdPutRequest{
		ApiService: a,
		ctx: ctx,
		achievementDefId: achievementDefId,
	}
}

// Execute executes the request
//  @return GithubComNotPlatformInternalServerTemplatesResponseTemplate
func (a *RegistryAPIService) RegistryAchievementsAchievementDefIdPutExecute(r ApiRegistryAchievementsAchievementDefIdPutRequest) (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GithubComNotPlatformInternalServerTemplatesResponseTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryAchievementsAchievementDefIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/achievements/{achievement_def_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"achievement_def_id"+"}", url.PathEscape(parameterValueToString(r.achievementDefId, "achievementDefId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryAchievementsGetRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	limit *int32
	offset *int32
}

// limit
func (r ApiRegistryAchievementsGetRequest) Limit(limit int32) ApiRegistryAchievementsGetRequest {
	r.limit = &limit
	return r
}

// offset
func (r ApiRegistryAchievementsGetRequest) Offset(offset int32) ApiRegistryAchievementsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiRegistryAchievementsGetRequest) Execute() (*RegistryAchievementsGet200Response, *http.Response, error) {
	return r.ApiService.RegistryAchievementsGetExecute(r)
}

/*
RegistryAchievementsGet List achievement-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegistryAchievementsGetRequest
*/
func (a *RegistryAPIService) RegistryAchievementsGet(ctx context.Context) ApiRegistryAchievementsGetRequest {
	return ApiRegistryAchievementsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegistryAchievementsGet200Response
func (a *RegistryAPIService) RegistryAchievementsGetExecute(r ApiRegistryAchievementsGetRequest) (*RegistryAchievementsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegistryAchievementsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryAchievementsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/achievements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryAchievementsPostRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	request *InternalModuleRegistryPresentationAchievementHttpCreateRequest
}

// request body
func (r ApiRegistryAchievementsPostRequest) Request(request InternalModuleRegistryPresentationAchievementHttpCreateRequest) ApiRegistryAchievementsPostRequest {
	r.request = &request
	return r
}

func (r ApiRegistryAchievementsPostRequest) Execute() (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	return r.ApiService.RegistryAchievementsPostExecute(r)
}

/*
RegistryAchievementsPost Create achievement-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegistryAchievementsPostRequest
*/
func (a *RegistryAPIService) RegistryAchievementsPost(ctx context.Context) ApiRegistryAchievementsPostRequest {
	return ApiRegistryAchievementsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GithubComNotPlatformInternalServerTemplatesResponseTemplate
func (a *RegistryAPIService) RegistryAchievementsPostExecute(r ApiRegistryAchievementsPostRequest) (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GithubComNotPlatformInternalServerTemplatesResponseTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryAchievementsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/achievements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryAppsGetRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	limit *int32
	offset *int32
}

// limit
func (r ApiRegistryAppsGetRequest) Limit(limit int32) ApiRegistryAppsGetRequest {
	r.limit = &limit
	return r
}

// offset
func (r ApiRegistryAppsGetRequest) Offset(offset int32) ApiRegistryAppsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiRegistryAppsGetRequest) Execute() (*RegistryAppsGet200Response, *http.Response, error) {
	return r.ApiService.RegistryAppsGetExecute(r)
}

/*
RegistryAppsGet List apps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegistryAppsGetRequest
*/
func (a *RegistryAPIService) RegistryAppsGet(ctx context.Context) ApiRegistryAppsGetRequest {
	return ApiRegistryAppsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegistryAppsGet200Response
func (a *RegistryAPIService) RegistryAppsGetExecute(r ApiRegistryAppsGetRequest) (*RegistryAppsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegistryAppsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryItemsGetRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	limit *int32
	offset *int32
}

// limit
func (r ApiRegistryItemsGetRequest) Limit(limit int32) ApiRegistryItemsGetRequest {
	r.limit = &limit
	return r
}

// offset
func (r ApiRegistryItemsGetRequest) Offset(offset int32) ApiRegistryItemsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiRegistryItemsGetRequest) Execute() (*RegistryItemsGet200Response, *http.Response, error) {
	return r.ApiService.RegistryItemsGetExecute(r)
}

/*
RegistryItemsGet List item-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegistryItemsGetRequest
*/
func (a *RegistryAPIService) RegistryItemsGet(ctx context.Context) ApiRegistryItemsGetRequest {
	return ApiRegistryItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegistryItemsGet200Response
func (a *RegistryAPIService) RegistryItemsGetExecute(r ApiRegistryItemsGetRequest) (*RegistryItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegistryItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryItemsItemDefIdDeleteRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	itemDefId string
}

func (r ApiRegistryItemsItemDefIdDeleteRequest) Execute() (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	return r.ApiService.RegistryItemsItemDefIdDeleteExecute(r)
}

/*
RegistryItemsItemDefIdDelete Delete item-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemDefId item_def_id
 @return ApiRegistryItemsItemDefIdDeleteRequest
*/
func (a *RegistryAPIService) RegistryItemsItemDefIdDelete(ctx context.Context, itemDefId string) ApiRegistryItemsItemDefIdDeleteRequest {
	return ApiRegistryItemsItemDefIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		itemDefId: itemDefId,
	}
}

// Execute executes the request
//  @return GithubComNotPlatformInternalServerTemplatesResponseTemplate
func (a *RegistryAPIService) RegistryItemsItemDefIdDeleteExecute(r ApiRegistryItemsItemDefIdDeleteRequest) (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GithubComNotPlatformInternalServerTemplatesResponseTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryItemsItemDefIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/items/{item_def_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"item_def_id"+"}", url.PathEscape(parameterValueToString(r.itemDefId, "itemDefId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryItemsItemDefIdGetRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	itemDefId string
}

func (r ApiRegistryItemsItemDefIdGetRequest) Execute() (*RegistryItemsItemDefIdGet200Response, *http.Response, error) {
	return r.ApiService.RegistryItemsItemDefIdGetExecute(r)
}

/*
RegistryItemsItemDefIdGet Get item-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemDefId item_def_id
 @return ApiRegistryItemsItemDefIdGetRequest
*/
func (a *RegistryAPIService) RegistryItemsItemDefIdGet(ctx context.Context, itemDefId string) ApiRegistryItemsItemDefIdGetRequest {
	return ApiRegistryItemsItemDefIdGetRequest{
		ApiService: a,
		ctx: ctx,
		itemDefId: itemDefId,
	}
}

// Execute executes the request
//  @return RegistryItemsItemDefIdGet200Response
func (a *RegistryAPIService) RegistryItemsItemDefIdGetExecute(r ApiRegistryItemsItemDefIdGetRequest) (*RegistryItemsItemDefIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegistryItemsItemDefIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryItemsItemDefIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/items/{item_def_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"item_def_id"+"}", url.PathEscape(parameterValueToString(r.itemDefId, "itemDefId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryItemsItemDefIdPutRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	itemDefId string
	request *InternalModuleRegistryPresentationItemHttpUpdateRequest
}

// request body
func (r ApiRegistryItemsItemDefIdPutRequest) Request(request InternalModuleRegistryPresentationItemHttpUpdateRequest) ApiRegistryItemsItemDefIdPutRequest {
	r.request = &request
	return r
}

func (r ApiRegistryItemsItemDefIdPutRequest) Execute() (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	return r.ApiService.RegistryItemsItemDefIdPutExecute(r)
}

/*
RegistryItemsItemDefIdPut Update item-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemDefId item_def_id
 @return ApiRegistryItemsItemDefIdPutRequest
*/
func (a *RegistryAPIService) RegistryItemsItemDefIdPut(ctx context.Context, itemDefId string) ApiRegistryItemsItemDefIdPutRequest {
	return ApiRegistryItemsItemDefIdPutRequest{
		ApiService: a,
		ctx: ctx,
		itemDefId: itemDefId,
	}
}

// Execute executes the request
//  @return GithubComNotPlatformInternalServerTemplatesResponseTemplate
func (a *RegistryAPIService) RegistryItemsItemDefIdPutExecute(r ApiRegistryItemsItemDefIdPutRequest) (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GithubComNotPlatformInternalServerTemplatesResponseTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryItemsItemDefIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/items/{item_def_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"item_def_id"+"}", url.PathEscape(parameterValueToString(r.itemDefId, "itemDefId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistryItemsPostRequest struct {
	ctx context.Context
	ApiService *RegistryAPIService
	request *InternalModuleRegistryPresentationItemHttpCreateRequest
}

// request body
func (r ApiRegistryItemsPostRequest) Request(request InternalModuleRegistryPresentationItemHttpCreateRequest) ApiRegistryItemsPostRequest {
	r.request = &request
	return r
}

func (r ApiRegistryItemsPostRequest) Execute() (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	return r.ApiService.RegistryItemsPostExecute(r)
}

/*
RegistryItemsPost Create item-def

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegistryItemsPostRequest
*/
func (a *RegistryAPIService) RegistryItemsPost(ctx context.Context) ApiRegistryItemsPostRequest {
	return ApiRegistryItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GithubComNotPlatformInternalServerTemplatesResponseTemplate
func (a *RegistryAPIService) RegistryItemsPostExecute(r ApiRegistryItemsPostRequest) (*GithubComNotPlatformInternalServerTemplatesResponseTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GithubComNotPlatformInternalServerTemplatesResponseTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegistryAPIService.RegistryItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registry/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWT"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GithubComNotPlatformInternalServerTemplatesResponseTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
