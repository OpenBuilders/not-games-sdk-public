/* tslint:disable */
/* eslint-disable */
/**
 * Swagger for Not Platform
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AchievementsGet200Response {
    'data'?: InternalModuleAchievementPresentationHttpListAchievementsResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface AchievementsIdGet200Response {
    'data'?: InternalModuleAchievementPresentationHttpGetAchievementOneResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface AchievementsPost200Response {
    'data'?: InternalModuleAchievementPresentationHttpCreateAchievementsResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface AuthGeneratePost200Response {
    'data'?: GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface DropsIdGet200Response {
    'data'?: string;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface DropsPost200Response {
    'data'?: InternalModuleDropsPresentationDropsHttpCreateDropResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest {
    'app_id'?: number;
    'refresh_token'?: string;
}
export interface GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateResponse {
    'private'?: string;
    'refresh_token'?: string;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest {
    'item_id'?: string;
    'quantity'?: number;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest {
    'app_id'?: number;
    'item_def_id'?: string;
    'tags'?: string;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelInventoryItemResponse {
    'account_id'?: number;
    'app_files'?: string;
    'app_id'?: number;
    'app_meta'?: string;
    'collection'?: string;
    'created_at'?: string;
    'default_tags'?: string;
    'description'?: string;
    'display_type'?: string;
    'game_only'?: boolean;
    'hidden'?: boolean;
    'icon_url'?: string;
    'item_def_id'?: string;
    'item_id'?: string;
    'marketable'?: boolean;
    'name'?: string;
    'quantity'?: number;
    'rarity'?: number;
    'serial'?: number;
    'supply'?: number;
    'tags'?: string;
    'tradable'?: boolean;
    'type'?: string;
    'updated_at'?: string;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelListItemsResponse {
    'items'?: Array<GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelInventoryItemResponse>;
    'pagination'?: GithubComNotPlatformInternalModuleSharedValueobjectPaginationResponse;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemPreflightResponse {
    'account'?: GithubComNotPlatformInternalModuleProfileDomainEntityAccount;
    'is_possible'?: boolean;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest {
    'account_to'?: number;
    'comment'?: string;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest {
    'app_id'?: number;
    'item_id'?: string;
    'tags'?: string;
}
export interface GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest {
    'app_meta'?: string;
    'rarity'?: number;
    'tags'?: string;
}
export interface GithubComNotPlatformInternalModuleProfileDomainEntityAccount {
    /**
     * telegram id
     */
    'account_id'?: number;
    'allow_pm'?: boolean;
    'avatar'?: string;
    'created_at'?: string;
    'first_name'?: string;
    'last_login'?: string;
    'last_name'?: string;
    'locale'?: string;
    /**
     * telegram group id
     */
    'squad_id'?: number;
    'user_name'?: string;
}
export interface GithubComNotPlatformInternalModuleProfilePresentationHttpModelAccountBackgroundResponse {
    'image'?: string;
    'is_default'?: boolean;
    'item_id'?: string;
    'name'?: string;
}
export interface GithubComNotPlatformInternalModuleProfilePresentationHttpModelAccountResponse {
    'avatar'?: string;
    'background'?: GithubComNotPlatformInternalModuleProfilePresentationHttpModelAccountBackgroundResponse;
    'created_at'?: string;
    'first_name'?: string;
    'id'?: number;
    'last_login'?: string;
    'last_name'?: string;
    'locale'?: string;
    /**
     * telegram group id
     */
    'squad_id'?: number;
    'username'?: string;
}
export interface GithubComNotPlatformInternalModuleRegistryPresentationItemHttpModelItemDefResponse {
    'app_files'?: string;
    'app_id'?: number;
    'bundle'?: string;
    'collection'?: string;
    'description'?: string;
    'display_type'?: string;
    'exchange'?: string;
    'game_only'?: boolean;
    'hidden'?: boolean;
    'icon_url'?: string;
    'item_def_id'?: string;
    'marketable'?: boolean;
    'max_supply'?: number;
    'name'?: string;
    'price'?: string;
    'promo'?: string;
    'rarity'?: number;
    'store_hidden'?: boolean;
    'store_images'?: string;
    'store_tags'?: string;
    'supply'?: number;
    'tags'?: string;
    'tradable'?: boolean;
    'type'?: string;
}
export interface GithubComNotPlatformInternalModuleRegistryPresentationItemHttpModelListItemDefResponse {
    'item_defs'?: Array<GithubComNotPlatformInternalModuleRegistryPresentationItemHttpModelItemDefResponse>;
    'pagination'?: GithubComNotPlatformInternalModuleSharedValueobjectPaginationResponse;
}
export interface GithubComNotPlatformInternalModuleSharedValueobjectPaginationResponse {
    'count'?: number;
    'offset'?: number;
    'total'?: number;
}
export interface GithubComNotPlatformInternalServerTemplatesResponseTemplate {
    'data'?: object;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface HttpAppOneResponse {
    'avatar'?: string;
    'background'?: string;
    'created_at'?: string;
    'id'?: number;
    'name'?: string;
    'slug'?: string;
    'socials'?: Array<HttpAppSocial>;
    'updated_at'?: string;
    'verified'?: boolean;
}
export interface HttpAppSocial {
    'title'?: string;
    'type'?: string;
    'url'?: string;
}
export interface HttpListAppResponse {
    'results'?: Array<HttpAppOneResponse>;
}
export interface InternalModuleAchievementPresentationHttpCreateAchievementOneResponse {
    'account_id'?: number;
    'achievement_def_id'?: string;
    'achievement_id'?: string;
    'app_id'?: number;
    'default_tags'?: string;
    'description'?: string;
    'display_type'?: string;
    'hidden'?: boolean;
    'icon_url'?: string;
    'name'?: string;
    'tags'?: string;
}
export interface InternalModuleAchievementPresentationHttpCreateAchievementsRequest {
    'achievement_def_ids'?: Array<string>;
    'tags'?: string;
}
export interface InternalModuleAchievementPresentationHttpCreateAchievementsResponse {
    'achievements'?: Array<InternalModuleAchievementPresentationHttpCreateAchievementOneResponse>;
}
export interface InternalModuleAchievementPresentationHttpGetAchievementOneResponse {
    'account_id'?: number;
    'achievement_def_id'?: string;
    'achievement_id'?: string;
    'app_id'?: number;
    'default_tags'?: string;
    'description'?: string;
    'display_type'?: string;
    'hidden'?: boolean;
    'icon_url'?: string;
    'name'?: string;
    'tags'?: string;
}
export interface InternalModuleAchievementPresentationHttpListAchievementsResponse {
    'achievements'?: Array<InternalModuleAchievementPresentationHttpGetAchievementOneResponse>;
    'pagination'?: GithubComNotPlatformInternalModuleSharedValueobjectPaginationResponse;
}
export interface InternalModuleDropsPresentationDropsHttpCreateDropRequest {
    'app_id'?: number;
    'available_at'?: string;
    'description'?: string;
    'finished_at'?: string;
    'item_def_ids'?: string;
    'random_pick'?: boolean;
    'whitelist'?: boolean;
    'whitelist_user_ids'?: Array<number>;
}
export interface InternalModuleDropsPresentationDropsHttpCreateDropResponse {
    'drop_id'?: string;
}
export interface InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest {
    'user_ids'?: Array<number>;
}
export interface InternalModuleRegistryPresentationAchievementHttpAchievementDefOneResponse {
    'achievement_def_id'?: string;
    'app_id'?: number;
    'description'?: string;
    'display_type'?: string;
    'hidden'?: boolean;
    'icon_url'?: string;
    'name'?: string;
    'tags'?: string;
}
export interface InternalModuleRegistryPresentationAchievementHttpCreateRequest {
    'achievement_def_id'?: string;
    'app_id'?: number;
    'description'?: string;
    'display_type'?: string;
    'hidden'?: boolean;
    'icon_url'?: string;
    'name'?: string;
    'tags'?: string;
}
export interface InternalModuleRegistryPresentationAchievementHttpListAchievementDefResponse {
    'pagination'?: GithubComNotPlatformInternalModuleSharedValueobjectPaginationResponse;
    'results'?: Array<InternalModuleRegistryPresentationAchievementHttpAchievementDefOneResponse>;
}
export interface InternalModuleRegistryPresentationAchievementHttpUpdateRequest {
    'app_id'?: number;
    'description'?: string;
    'display_type'?: string;
    'hidden'?: boolean;
    'icon_url'?: string;
    'name'?: string;
    'tags'?: string;
}
export interface InternalModuleRegistryPresentationItemHttpCreateRequest {
    'app_files'?: string;
    'app_id'?: number;
    'bundle'?: string;
    'collection'?: string;
    'description'?: string;
    'display_type'?: string;
    'exchange'?: string;
    'game_only'?: boolean;
    'hidden'?: boolean;
    'icon_url'?: string;
    'item_def_id'?: string;
    'marketable'?: boolean;
    'max_supply'?: number;
    'name'?: string;
    'price'?: string;
    'promo'?: string;
    'rarity'?: number;
    'store_hidden'?: boolean;
    'store_images'?: string;
    'store_tags'?: string;
    'tags'?: string;
    'tradable'?: boolean;
    'type'?: string;
}
export interface InternalModuleRegistryPresentationItemHttpUpdateRequest {
    'app_files'?: string;
    'app_id'?: number;
    'bundle'?: string;
    'collection'?: string;
    'description'?: string;
    'display_type'?: string;
    'exchange'?: string;
    'game_only'?: boolean;
    'hidden'?: boolean;
    'icon_url'?: string;
    'marketable'?: boolean;
    'max_supply'?: number;
    'name'?: string;
    'price'?: string;
    'promo'?: string;
    'store_hidden'?: boolean;
    'store_images'?: string;
    'store_tags'?: string;
    'tradable'?: boolean;
}
export interface InternalModuleSquadsPresentationSquadsHttpGetSquadOneResponse {
    'avatar'?: string;
    'chat_id'?: number;
    'id'?: number;
    'members_amount'?: number;
    'name'?: string;
    'slug'?: string;
}
export interface InternalModuleSquadsPresentationSquadsHttpListSquadsResponse {
    'squads'?: Array<InternalModuleSquadsPresentationSquadsHttpGetSquadOneResponse>;
}
export interface InventoryItemsGet200Response {
    'data'?: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelListItemsResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface InventoryItemsItemIdGet200Response {
    'data'?: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelInventoryItemResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface InventoryItemsItemIdTransferPreflightPost200Response {
    'data'?: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemPreflightResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface InventoryItemsUnpackPost200Response {
    'data'?: Array<string>;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface ProfileAccountIdGet200Response {
    'data'?: GithubComNotPlatformInternalModuleProfilePresentationHttpModelAccountResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface RegistryAchievementsAchievementDefIdGet200Response {
    'data'?: InternalModuleRegistryPresentationAchievementHttpAchievementDefOneResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface RegistryAchievementsGet200Response {
    'data'?: InternalModuleRegistryPresentationAchievementHttpListAchievementDefResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface RegistryAppsGet200Response {
    'data'?: HttpListAppResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface RegistryItemsGet200Response {
    'data'?: GithubComNotPlatformInternalModuleRegistryPresentationItemHttpModelListItemDefResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface RegistryItemsItemDefIdGet200Response {
    'data'?: GithubComNotPlatformInternalModuleRegistryPresentationItemHttpModelItemDefResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface SquadsGet200Response {
    'data'?: InternalModuleSquadsPresentationSquadsHttpListSquadsResponse;
    'error_code'?: string;
    'ok'?: boolean;
}
export interface SquadsIdGet200Response {
    'data'?: InternalModuleSquadsPresentationSquadsHttpGetSquadOneResponse;
    'error_code'?: string;
    'ok'?: boolean;
}

/**
 * AchievementsApi - axios parameter creator
 */
export const AchievementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List achievements
         * @param {string} appId app id
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsGet: async (appId: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('achievementsGet', 'appId', appId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('achievementsGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('achievementsGet', 'offset', offset)
            const localVarPath = `/achievements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get achievement
         * @param {string} id achievement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('achievementsIdGet', 'id', id)
            const localVarPath = `/achievements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create achievement
         * @param {InternalModuleAchievementPresentationHttpCreateAchievementsRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsPost: async (request: InternalModuleAchievementPresentationHttpCreateAchievementsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('achievementsPost', 'request', request)
            const localVarPath = `/achievements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AchievementsApi - functional programming interface
 */
export const AchievementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AchievementsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List achievements
         * @param {string} appId app id
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async achievementsGet(appId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchievementsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.achievementsGet(appId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AchievementsApi.achievementsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get achievement
         * @param {string} id achievement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async achievementsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchievementsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.achievementsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AchievementsApi.achievementsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create achievement
         * @param {InternalModuleAchievementPresentationHttpCreateAchievementsRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async achievementsPost(request: InternalModuleAchievementPresentationHttpCreateAchievementsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchievementsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.achievementsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AchievementsApi.achievementsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AchievementsApi - factory interface
 */
export const AchievementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AchievementsApiFp(configuration)
    return {
        /**
         * 
         * @summary List achievements
         * @param {string} appId app id
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsGet(appId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<AchievementsGet200Response> {
            return localVarFp.achievementsGet(appId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get achievement
         * @param {string} id achievement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AchievementsIdGet200Response> {
            return localVarFp.achievementsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create achievement
         * @param {InternalModuleAchievementPresentationHttpCreateAchievementsRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsPost(request: InternalModuleAchievementPresentationHttpCreateAchievementsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AchievementsPost200Response> {
            return localVarFp.achievementsPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AchievementsApi - object-oriented interface
 */
export class AchievementsApi extends BaseAPI {
    /**
     * 
     * @summary List achievements
     * @param {string} appId app id
     * @param {number} limit limit
     * @param {number} offset offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public achievementsGet(appId: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return AchievementsApiFp(this.configuration).achievementsGet(appId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get achievement
     * @param {string} id achievement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public achievementsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AchievementsApiFp(this.configuration).achievementsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create achievement
     * @param {InternalModuleAchievementPresentationHttpCreateAchievementsRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public achievementsPost(request: InternalModuleAchievementPresentationHttpCreateAchievementsRequest, options?: RawAxiosRequestConfig) {
        return AchievementsApiFp(this.configuration).achievementsPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate new auth
         * @param {GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGeneratePost: async (request: GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authGeneratePost', 'request', request)
            const localVarPath = `/auth/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate new auth
         * @param {GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGeneratePost(request: GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthGeneratePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGeneratePost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authGeneratePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate new auth
         * @param {GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGeneratePost(request: GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthGeneratePost200Response> {
            return localVarFp.authGeneratePost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Generate new auth
     * @param {GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authGeneratePost(request: GithubComNotPlatformInternalModuleAuthPresentationAuthorizationHttpModelAuthGenerateRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGeneratePost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DropsApi - axios parameter creator
 */
export const DropsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check user eligibility for a drop. Account ID must be provided in authorization token. This only used for game to know if user can claim drop.
         * @summary Check user eligibility for a drop
         * @param {string} id Drop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dropsIdGet', 'id', id)
            const localVarPath = `/drops/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whitelist users for a drop
         * @param {string} id Drop ID
         * @param {InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest} request Whitelist Drop User Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropsIdWhitelistPost: async (id: string, request: InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dropsIdWhitelistPost', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('dropsIdWhitelistPost', 'request', request)
            const localVarPath = `/drops/{id}/whitelist`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new drop. App ID must be provided in authorization token
         * @summary Create a new drop
         * @param {InternalModuleDropsPresentationDropsHttpCreateDropRequest} request Create Drop Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropsPost: async (request: InternalModuleDropsPresentationDropsHttpCreateDropRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('dropsPost', 'request', request)
            const localVarPath = `/drops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DropsApi - functional programming interface
 */
export const DropsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DropsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check user eligibility for a drop. Account ID must be provided in authorization token. This only used for game to know if user can claim drop.
         * @summary Check user eligibility for a drop
         * @param {string} id Drop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DropsApi.dropsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Whitelist users for a drop
         * @param {string} id Drop ID
         * @param {InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest} request Whitelist Drop User Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropsIdWhitelistPost(id: string, request: InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropsIdWhitelistPost(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DropsApi.dropsIdWhitelistPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new drop. App ID must be provided in authorization token
         * @summary Create a new drop
         * @param {InternalModuleDropsPresentationDropsHttpCreateDropRequest} request Create Drop Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropsPost(request: InternalModuleDropsPresentationDropsHttpCreateDropRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DropsApi.dropsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DropsApi - factory interface
 */
export const DropsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DropsApiFp(configuration)
    return {
        /**
         * Check user eligibility for a drop. Account ID must be provided in authorization token. This only used for game to know if user can claim drop.
         * @summary Check user eligibility for a drop
         * @param {string} id Drop ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DropsIdGet200Response> {
            return localVarFp.dropsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whitelist users for a drop
         * @param {string} id Drop ID
         * @param {InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest} request Whitelist Drop User Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropsIdWhitelistPost(id: string, request: InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.dropsIdWhitelistPost(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new drop. App ID must be provided in authorization token
         * @summary Create a new drop
         * @param {InternalModuleDropsPresentationDropsHttpCreateDropRequest} request Create Drop Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropsPost(request: InternalModuleDropsPresentationDropsHttpCreateDropRequest, options?: RawAxiosRequestConfig): AxiosPromise<DropsPost200Response> {
            return localVarFp.dropsPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DropsApi - object-oriented interface
 */
export class DropsApi extends BaseAPI {
    /**
     * Check user eligibility for a drop. Account ID must be provided in authorization token. This only used for game to know if user can claim drop.
     * @summary Check user eligibility for a drop
     * @param {string} id Drop ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public dropsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DropsApiFp(this.configuration).dropsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whitelist users for a drop
     * @param {string} id Drop ID
     * @param {InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest} request Whitelist Drop User Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public dropsIdWhitelistPost(id: string, request: InternalModuleDropsPresentationDropsHttpWhitelistDropUserRequest, options?: RawAxiosRequestConfig) {
        return DropsApiFp(this.configuration).dropsIdWhitelistPost(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new drop. App ID must be provided in authorization token
     * @summary Create a new drop
     * @param {InternalModuleDropsPresentationDropsHttpCreateDropRequest} request Create Drop Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public dropsPost(request: InternalModuleDropsPresentationDropsHttpCreateDropRequest, options?: RawAxiosRequestConfig) {
        return DropsApiFp(this.configuration).dropsPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InventoryApi - axios parameter creator
 */
export const InventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate item
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsGeneratePost: async (request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('inventoryItemsGeneratePost', 'request', request)
            const localVarPath = `/inventory/items/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List items
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsGet: async (limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('inventoryItemsGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('inventoryItemsGet', 'offset', offset)
            const localVarPath = `/inventory/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Consume item
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdConsumePost: async (itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('inventoryItemsItemIdConsumePost', 'itemId', itemId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('inventoryItemsItemIdConsumePost', 'request', request)
            const localVarPath = `/inventory/items/{item_id}/consume`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get item
         * @param {string} itemId item id (uuid)
         * @param {number} [appId] app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdGet: async (itemId: string, appId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('inventoryItemsItemIdGet', 'itemId', itemId)
            const localVarPath = `/inventory/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update item
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdPut: async (itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('inventoryItemsItemIdPut', 'itemId', itemId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('inventoryItemsItemIdPut', 'request', request)
            const localVarPath = `/inventory/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer item to another account
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdTransferPost: async (itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('inventoryItemsItemIdTransferPost', 'itemId', itemId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('inventoryItemsItemIdTransferPost', 'request', request)
            const localVarPath = `/inventory/items/{item_id}/transfer`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check transfer item possibility to another account
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdTransferPreflightPost: async (itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('inventoryItemsItemIdTransferPreflightPost', 'itemId', itemId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('inventoryItemsItemIdTransferPreflightPost', 'request', request)
            const localVarPath = `/inventory/items/{item_id}/transfer-preflight`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpack item
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsUnpackPost: async (request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('inventoryItemsUnpackPost', 'request', request)
            const localVarPath = `/inventory/items/unpack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate item
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsGeneratePost(request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsGeneratePost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsGeneratePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List items
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItemsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Consume item
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsItemIdConsumePost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsItemIdConsumePost(itemId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsItemIdConsumePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get item
         * @param {string} itemId item id (uuid)
         * @param {number} [appId] app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsItemIdGet(itemId: string, appId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItemsItemIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsItemIdGet(itemId, appId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsItemIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update item
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsItemIdPut(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsItemIdPut(itemId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsItemIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transfer item to another account
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsItemIdTransferPost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsItemIdTransferPost(itemId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsItemIdTransferPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check transfer item possibility to another account
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsItemIdTransferPreflightPost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItemsItemIdTransferPreflightPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsItemIdTransferPreflightPost(itemId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsItemIdTransferPreflightPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unpack item
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inventoryItemsUnpackPost(request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItemsUnpackPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inventoryItemsUnpackPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.inventoryItemsUnpackPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InventoryApi - factory interface
 */
export const InventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate item
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsGeneratePost(request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<DropsIdGet200Response> {
            return localVarFp.inventoryItemsGeneratePost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List items
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItemsGet200Response> {
            return localVarFp.inventoryItemsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Consume item
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdConsumePost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.inventoryItemsItemIdConsumePost(itemId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get item
         * @param {string} itemId item id (uuid)
         * @param {number} [appId] app id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdGet(itemId: string, appId?: number, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItemsItemIdGet200Response> {
            return localVarFp.inventoryItemsItemIdGet(itemId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update item
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdPut(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.inventoryItemsItemIdPut(itemId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer item to another account
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdTransferPost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.inventoryItemsItemIdTransferPost(itemId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check transfer item possibility to another account
         * @param {string} itemId item id (uuid)
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsItemIdTransferPreflightPost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItemsItemIdTransferPreflightPost200Response> {
            return localVarFp.inventoryItemsItemIdTransferPreflightPost(itemId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unpack item
         * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inventoryItemsUnpackPost(request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItemsUnpackPost200Response> {
            return localVarFp.inventoryItemsUnpackPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoryApi - object-oriented interface
 */
export class InventoryApi extends BaseAPI {
    /**
     * 
     * @summary Generate item
     * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsGeneratePost(request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelGenerateItemRequest, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsGeneratePost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List items
     * @param {number} limit limit
     * @param {number} offset offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsGet(limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Consume item
     * @param {string} itemId item id (uuid)
     * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsItemIdConsumePost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelConsumeItemRequest, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsItemIdConsumePost(itemId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get item
     * @param {string} itemId item id (uuid)
     * @param {number} [appId] app id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsItemIdGet(itemId: string, appId?: number, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsItemIdGet(itemId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update item
     * @param {string} itemId item id (uuid)
     * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsItemIdPut(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUpdateItemRequest, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsItemIdPut(itemId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer item to another account
     * @param {string} itemId item id (uuid)
     * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsItemIdTransferPost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsItemIdTransferPost(itemId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check transfer item possibility to another account
     * @param {string} itemId item id (uuid)
     * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsItemIdTransferPreflightPost(itemId: string, request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelTransferItemRequest, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsItemIdTransferPreflightPost(itemId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unpack item
     * @param {GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inventoryItemsUnpackPost(request: GithubComNotPlatformInternalModuleInventoryPresentationInventoryItemHttpModelUnpackItemRequest, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).inventoryItemsUnpackPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get account
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileAccountIdGet: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('profileAccountIdGet', 'accountId', accountId)
            const localVarPath = `/profile/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get account
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileAccountIdGet(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileAccountIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileAccountIdGet(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profileAccountIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Get account
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileAccountIdGet(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProfileAccountIdGet200Response> {
            return localVarFp.profileAccountIdGet(accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @summary Get account
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profileAccountIdGet(accountId: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileAccountIdGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegistryApi - axios parameter creator
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsAchievementDefIdDelete: async (achievementDefId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'achievementDefId' is not null or undefined
            assertParamExists('registryAchievementsAchievementDefIdDelete', 'achievementDefId', achievementDefId)
            const localVarPath = `/registry/achievements/{achievement_def_id}`
                .replace(`{${"achievement_def_id"}}`, encodeURIComponent(String(achievementDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsAchievementDefIdGet: async (achievementDefId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'achievementDefId' is not null or undefined
            assertParamExists('registryAchievementsAchievementDefIdGet', 'achievementDefId', achievementDefId)
            const localVarPath = `/registry/achievements/{achievement_def_id}`
                .replace(`{${"achievement_def_id"}}`, encodeURIComponent(String(achievementDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {InternalModuleRegistryPresentationAchievementHttpUpdateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsAchievementDefIdPut: async (achievementDefId: string, request: InternalModuleRegistryPresentationAchievementHttpUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'achievementDefId' is not null or undefined
            assertParamExists('registryAchievementsAchievementDefIdPut', 'achievementDefId', achievementDefId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('registryAchievementsAchievementDefIdPut', 'request', request)
            const localVarPath = `/registry/achievements/{achievement_def_id}`
                .replace(`{${"achievement_def_id"}}`, encodeURIComponent(String(achievementDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List achievement-def
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsGet: async (limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('registryAchievementsGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('registryAchievementsGet', 'offset', offset)
            const localVarPath = `/registry/achievements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create achievement-def
         * @param {InternalModuleRegistryPresentationAchievementHttpCreateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsPost: async (request: InternalModuleRegistryPresentationAchievementHttpCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('registryAchievementsPost', 'request', request)
            const localVarPath = `/registry/achievements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List apps
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAppsGet: async (limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('registryAppsGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('registryAppsGet', 'offset', offset)
            const localVarPath = `/registry/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List item-def
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsGet: async (limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('registryItemsGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('registryItemsGet', 'offset', offset)
            const localVarPath = `/registry/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete item-def
         * @param {string} itemDefId item_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsItemDefIdDelete: async (itemDefId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemDefId' is not null or undefined
            assertParamExists('registryItemsItemDefIdDelete', 'itemDefId', itemDefId)
            const localVarPath = `/registry/items/{item_def_id}`
                .replace(`{${"item_def_id"}}`, encodeURIComponent(String(itemDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get item-def
         * @param {string} itemDefId item_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsItemDefIdGet: async (itemDefId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemDefId' is not null or undefined
            assertParamExists('registryItemsItemDefIdGet', 'itemDefId', itemDefId)
            const localVarPath = `/registry/items/{item_def_id}`
                .replace(`{${"item_def_id"}}`, encodeURIComponent(String(itemDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update item-def
         * @param {string} itemDefId item_def_id
         * @param {InternalModuleRegistryPresentationItemHttpUpdateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsItemDefIdPut: async (itemDefId: string, request: InternalModuleRegistryPresentationItemHttpUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemDefId' is not null or undefined
            assertParamExists('registryItemsItemDefIdPut', 'itemDefId', itemDefId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('registryItemsItemDefIdPut', 'request', request)
            const localVarPath = `/registry/items/{item_def_id}`
                .replace(`{${"item_def_id"}}`, encodeURIComponent(String(itemDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create item-def
         * @param {InternalModuleRegistryPresentationItemHttpCreateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsPost: async (request: InternalModuleRegistryPresentationItemHttpCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('registryItemsPost', 'request', request)
            const localVarPath = `/registry/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryAchievementsAchievementDefIdDelete(achievementDefId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryAchievementsAchievementDefIdDelete(achievementDefId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryAchievementsAchievementDefIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryAchievementsAchievementDefIdGet(achievementDefId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryAchievementsAchievementDefIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryAchievementsAchievementDefIdGet(achievementDefId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryAchievementsAchievementDefIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {InternalModuleRegistryPresentationAchievementHttpUpdateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryAchievementsAchievementDefIdPut(achievementDefId: string, request: InternalModuleRegistryPresentationAchievementHttpUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryAchievementsAchievementDefIdPut(achievementDefId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryAchievementsAchievementDefIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List achievement-def
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryAchievementsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryAchievementsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryAchievementsGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryAchievementsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create achievement-def
         * @param {InternalModuleRegistryPresentationAchievementHttpCreateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryAchievementsPost(request: InternalModuleRegistryPresentationAchievementHttpCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryAchievementsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryAchievementsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List apps
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryAppsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryAppsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryAppsGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryAppsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List item-def
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryItemsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryItemsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryItemsGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete item-def
         * @param {string} itemDefId item_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryItemsItemDefIdDelete(itemDefId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryItemsItemDefIdDelete(itemDefId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryItemsItemDefIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get item-def
         * @param {string} itemDefId item_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryItemsItemDefIdGet(itemDefId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryItemsItemDefIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryItemsItemDefIdGet(itemDefId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryItemsItemDefIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update item-def
         * @param {string} itemDefId item_def_id
         * @param {InternalModuleRegistryPresentationItemHttpUpdateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryItemsItemDefIdPut(itemDefId: string, request: InternalModuleRegistryPresentationItemHttpUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryItemsItemDefIdPut(itemDefId, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryItemsItemDefIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create item-def
         * @param {InternalModuleRegistryPresentationItemHttpCreateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryItemsPost(request: InternalModuleRegistryPresentationItemHttpCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryItemsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registryItemsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegistryApi - factory interface
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsAchievementDefIdDelete(achievementDefId: string, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.registryAchievementsAchievementDefIdDelete(achievementDefId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsAchievementDefIdGet(achievementDefId: string, options?: RawAxiosRequestConfig): AxiosPromise<RegistryAchievementsAchievementDefIdGet200Response> {
            return localVarFp.registryAchievementsAchievementDefIdGet(achievementDefId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update achievement-def
         * @param {string} achievementDefId achievement_def_id
         * @param {InternalModuleRegistryPresentationAchievementHttpUpdateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsAchievementDefIdPut(achievementDefId: string, request: InternalModuleRegistryPresentationAchievementHttpUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.registryAchievementsAchievementDefIdPut(achievementDefId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List achievement-def
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<RegistryAchievementsGet200Response> {
            return localVarFp.registryAchievementsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create achievement-def
         * @param {InternalModuleRegistryPresentationAchievementHttpCreateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAchievementsPost(request: InternalModuleRegistryPresentationAchievementHttpCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.registryAchievementsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List apps
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryAppsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<RegistryAppsGet200Response> {
            return localVarFp.registryAppsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List item-def
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsGet(limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<RegistryItemsGet200Response> {
            return localVarFp.registryItemsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete item-def
         * @param {string} itemDefId item_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsItemDefIdDelete(itemDefId: string, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.registryItemsItemDefIdDelete(itemDefId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get item-def
         * @param {string} itemDefId item_def_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsItemDefIdGet(itemDefId: string, options?: RawAxiosRequestConfig): AxiosPromise<RegistryItemsItemDefIdGet200Response> {
            return localVarFp.registryItemsItemDefIdGet(itemDefId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update item-def
         * @param {string} itemDefId item_def_id
         * @param {InternalModuleRegistryPresentationItemHttpUpdateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsItemDefIdPut(itemDefId: string, request: InternalModuleRegistryPresentationItemHttpUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.registryItemsItemDefIdPut(itemDefId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create item-def
         * @param {InternalModuleRegistryPresentationItemHttpCreateRequest} request request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryItemsPost(request: InternalModuleRegistryPresentationItemHttpCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComNotPlatformInternalServerTemplatesResponseTemplate> {
            return localVarFp.registryItemsPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @summary Delete achievement-def
     * @param {string} achievementDefId achievement_def_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryAchievementsAchievementDefIdDelete(achievementDefId: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryAchievementsAchievementDefIdDelete(achievementDefId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get achievement-def
     * @param {string} achievementDefId achievement_def_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryAchievementsAchievementDefIdGet(achievementDefId: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryAchievementsAchievementDefIdGet(achievementDefId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update achievement-def
     * @param {string} achievementDefId achievement_def_id
     * @param {InternalModuleRegistryPresentationAchievementHttpUpdateRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryAchievementsAchievementDefIdPut(achievementDefId: string, request: InternalModuleRegistryPresentationAchievementHttpUpdateRequest, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryAchievementsAchievementDefIdPut(achievementDefId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List achievement-def
     * @param {number} limit limit
     * @param {number} offset offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryAchievementsGet(limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryAchievementsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create achievement-def
     * @param {InternalModuleRegistryPresentationAchievementHttpCreateRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryAchievementsPost(request: InternalModuleRegistryPresentationAchievementHttpCreateRequest, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryAchievementsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List apps
     * @param {number} limit limit
     * @param {number} offset offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryAppsGet(limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryAppsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List item-def
     * @param {number} limit limit
     * @param {number} offset offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryItemsGet(limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryItemsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete item-def
     * @param {string} itemDefId item_def_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryItemsItemDefIdDelete(itemDefId: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryItemsItemDefIdDelete(itemDefId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get item-def
     * @param {string} itemDefId item_def_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryItemsItemDefIdGet(itemDefId: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryItemsItemDefIdGet(itemDefId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update item-def
     * @param {string} itemDefId item_def_id
     * @param {InternalModuleRegistryPresentationItemHttpUpdateRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryItemsItemDefIdPut(itemDefId: string, request: InternalModuleRegistryPresentationItemHttpUpdateRequest, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryItemsItemDefIdPut(itemDefId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create item-def
     * @param {InternalModuleRegistryPresentationItemHttpCreateRequest} request request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public registryItemsPost(request: InternalModuleRegistryPresentationItemHttpCreateRequest, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registryItemsPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SquadsApi - axios parameter creator
 */
export const SquadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List squads
         * @param {number} limit Limit
         * @param {number} offset Offset
         * @param {string} [slug] Slug
         * @param {string} [sort] Sort
         * @param {number} [minMembersAmount] Min members amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        squadsGet: async (limit: number, offset: number, slug?: string, sort?: string, minMembersAmount?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('squadsGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('squadsGet', 'offset', offset)
            const localVarPath = `/squads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (minMembersAmount !== undefined) {
                localVarQueryParameter['min_members_amount'] = minMembersAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get squad by id
         * @param {number} id Squad ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        squadsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('squadsIdGet', 'id', id)
            const localVarPath = `/squads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SquadsApi - functional programming interface
 */
export const SquadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SquadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List squads
         * @param {number} limit Limit
         * @param {number} offset Offset
         * @param {string} [slug] Slug
         * @param {string} [sort] Sort
         * @param {number} [minMembersAmount] Min members amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async squadsGet(limit: number, offset: number, slug?: string, sort?: string, minMembersAmount?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SquadsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.squadsGet(limit, offset, slug, sort, minMembersAmount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SquadsApi.squadsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get squad by id
         * @param {number} id Squad ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async squadsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SquadsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.squadsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SquadsApi.squadsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SquadsApi - factory interface
 */
export const SquadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SquadsApiFp(configuration)
    return {
        /**
         * 
         * @summary List squads
         * @param {number} limit Limit
         * @param {number} offset Offset
         * @param {string} [slug] Slug
         * @param {string} [sort] Sort
         * @param {number} [minMembersAmount] Min members amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        squadsGet(limit: number, offset: number, slug?: string, sort?: string, minMembersAmount?: number, options?: RawAxiosRequestConfig): AxiosPromise<SquadsGet200Response> {
            return localVarFp.squadsGet(limit, offset, slug, sort, minMembersAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get squad by id
         * @param {number} id Squad ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        squadsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SquadsIdGet200Response> {
            return localVarFp.squadsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SquadsApi - object-oriented interface
 */
export class SquadsApi extends BaseAPI {
    /**
     * 
     * @summary List squads
     * @param {number} limit Limit
     * @param {number} offset Offset
     * @param {string} [slug] Slug
     * @param {string} [sort] Sort
     * @param {number} [minMembersAmount] Min members amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public squadsGet(limit: number, offset: number, slug?: string, sort?: string, minMembersAmount?: number, options?: RawAxiosRequestConfig) {
        return SquadsApiFp(this.configuration).squadsGet(limit, offset, slug, sort, minMembersAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get squad by id
     * @param {number} id Squad ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public squadsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return SquadsApiFp(this.configuration).squadsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



